#!/usr/bin/env bash

####### Configure environment

set -e            # fail fast
set -o pipefail   # don't ignore exit codes when piping output
# set -x          # enable debugging

# Configure directories
build_dir=$1
cache_dir=$2
env_dir=$3
bp_dir=$(cd $(dirname $0); cd ..; pwd)
heroku_dir=$build_dir/.heroku
logfile=$heroku_dir/temp/node-log.txt

# Load some convenience functions like status(), echo(), and indent()
source $bp_dir/bin/common.sh

# Output version
status "Node Buildpack v63"

# Avoid GIT_DIR leak from previous build steps
unset GIT_DIR

# Create directories & log file
mkdir -p $heroku_dir/node
mkdir -p $heroku_dir/temp
touch $logfile

# Trap errors
trap tail_error_log ERR

# Load config vars into environment; start with defaults
npm_config_production=true

if [ -d "$env_dir" ]; then
  export_env_dir $env_dir
fi

####### Determine current state

# What was the last released node version?
if test -f $cache_dir/node/node-version; then
  previous_node_version=$(cat $cache_dir/node/node-version)
else
  previous_node_version=""
fi

# Is there a requested semver range for node?
semver_range="$(cat $build_dir/package.json | $bp_dir/vendor/jq -r .engines.node)"
node_version=""
if [ "$semver_range" == "null" ]; then
  semver_range=""
  has_semver=false
  has_specific_version=false
else
  has_semver=true
  if [[ "$semver_range" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    has_specific_version=true
    node_version="$semver_range"
  else
    has_specific_version=false
  fi
fi

# Is there a requested semver range for npm?
npm_range="$(cat $build_dir/package.json | $bp_dir/vendor/jq -r .engines.npm)"
npm_version=""
if [ "$npm_range" == "null" ]; then
  npm_range=""
  override_npm=false
else
  override_npm=true
  if [[ "$npm_range" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    specific_npm_version=true
    npm_version="$npm_range"
  else
    specific_npm_version=false
  fi
fi

# Start by assuming we can't start
start_method=""

# Does server.js exist?
if [ -f $build_dir/server.js ]; then
  has_server=true
  start_method="server.js"
else
  has_server=false
fi

# Can we use npm start? (default = node server.js)
npm_start=$(cat $build_dir/package.json | $bp_dir/vendor/jq -r .scripts.start)
if [ "$npm_start" != "null" ]; then
  has_start=true
  start_method="npm start"
else
  has_start=false
fi

# Is a Procfile provided?
if test -d $build_dir/Procfile; then
  has_procfile=true
  start_method="Procfile"
else
  has_procfile=false
fi

# Do we have cached node_modules?
if test -d $cache_dir/node/node_modules; then
  node_modules_cached=true
else
  node_modules_cached=false
fi

# Does node_modules dir already exist?
if test -d $build_dir/node_modules; then
  node_modules_prebuilt=true
else
  node_modules_prebuilt=false
fi

# Are node_modules shrinkwrapped?
if test -d $build_dir/npm-shrinkwrap.json; then
  shrinkwrapped=true
else
  shrinkwrapped=false
fi

####### Provide debugging info and feedback

echo ""
status "Node version ${semver_range:-(unspecified)} requested in package.json"

if [ "$semver_range" == "" ]; then
  protip "You should specify a node version in package.json" "https://devcenter.heroku.com/articles/nodejs-support#specifying-a-node-js-version"
elif [ "$semver_range" == "*" ]; then
  protip "Avoid using semver ranges like '*' in engines.node" "https://devcenter.heroku.com/articles/nodejs-support#specifying-a-node-js-version"
elif [ ${semver_range:0:1} == ">" ]; then
  protip "Avoid using semver ranges starting with '>' in engines.node" "https://devcenter.heroku.com/articles/nodejs-support#specifying-a-node-js-version"
fi

if $override_npm; then
  status "Npm version $npm_range requested in package.json"
else
  status "Using standard npm bundled with node"
fi

if [ "$start_method" == "" ]; then
  status "No start mechanism found"
  protip "Use a Procfile, package.json start script, or server.js file to start your app" "https://devcenter.heroku.com/articles/nodejs-support#runtime-behavior"
else
  status "App will start via $start_method"
fi

if $node_modules_cached; then
  status "node_modules exists in cache"
else
  status "node_modules cache is empty"
fi

if $node_modules_prebuilt; then
  status "node_modules have been prebuilt"
  protip "Avoid checking node_modules into source control" "https://www.npmjs.org/doc/misc/npm-faq.html#should-i-check-my-node_modules-folder-into-git-"
elif $shrinkwrapped; then
  status "node_modules will be updated from npm-shrinkwrap.json"
else
  status "node_modules will be updated from package.json"
fi

status "npm_config_production=$npm_config_production"

####### Vendor in binaries

echo ""

# Resolve non-specific node versions using semver.io
if ! $has_specific_version; then
  status "Resolving node version ${semver_range:-(latest stable)} via semver.io..."
  node_version=$(curl --silent --get --data-urlencode "range=${semver_range}" https://semver.io/node/resolve)
fi

# Is this a new version of node?
if [ "$previous_node_version" != "" ] && [ "$node_version" != "$previous_node_version" ]; then
  new_node_version=true
else
  new_node_version=false
fi

# Download node from Heroku's S3 mirror of nodejs.org/dist
status "Downloading and installing node $node_version..."
node_url="http://s3pository.heroku.com/node/v$node_version/node-v$node_version-linux-x64.tar.gz"
curl $node_url -s -o - | tar xzf - -C $heroku_dir/temp

# Move node (and npm) into .heroku/node and make them executable
mv $heroku_dir/temp/node-v$node_version-linux-x64/* $heroku_dir/node
chmod +x $heroku_dir/node/bin/*
PATH=$heroku_dir/node/bin:$PATH

# Optionally bootstrap a different npm version
if $override_npm; then
  if ! $specific_npm_version; then
    status "Resolving npm version ${npm_range} with semver.io..."
    npm_version=$(curl --silent --get --data-urlencode "range=${npm_range}" https://semver.io/npm/resolve)
  fi
  status "Downloading and installing npm $npm_version (replacing bundled version `npm --version`)..."
  npm install -g npm@$npm_version >> $logfile 2>&1 | indent
fi

# Run subsequent commands from the build directory
cd $build_dir

####### Build the project's dependencies

echo ""

if $node_modules_prebuilt; then
  status "Found existing node_modules directory; skipping cache and installation"
  status "Rebuilding any native dependencies"
  npm rebuild >> $logfile 2>&1 | indent
else
  if $new_node_version; then
    status "Changing node versions, $previous_node_version => $node_version; skipping cache"
    npm rebuild >> $logfile 2>&1 | indent
  elif $node_modules_cached; then
    status "Restoring node_modules from cache"
    cp -r $cache_dir/node/node_modules $build_dir/
    status "Pruning cached dependencies"
    npm prune >> $logfile 2>&1 | indent
  fi

  status "Installing dependencies"
  npm install --userconfig $build_dir/.npmrc >> $logfile 2>&1 | indent
  status "Updating dependencies"
  npm update >> $logfile 2>&1 | indent
  status "Deduping dependencies"
  npm dedupe >> $logfile 2>&1 | indent
fi

# List the installed dependencies
echo ""
npm ls

####### Create a Procfile if possible

if ! $has_procfile; then
  if $has_start || $has_server; then
    status "No Procfile found; Adding 'web: npm start' to new Procfile"
    echo "web: npm start" > $build_dir/Procfile
  fi
fi

####### Create the runtime environment (profile.d)

status "Building runtime environment"
mkdir -p $build_dir/.profile.d

# Add binary locations to the PATH
echo "export PATH=\"\$HOME/.heroku/node/bin:\$HOME/bin:\$HOME/node_modules/.bin:\$PATH\";" > $build_dir/.profile.d/nodejs.sh

# Export npm_config
echo "npm_config_production=$npm_config_production" >> $build_dir/.profile.d/nodejs.sh

# Export NODE_HOME
echo "export NODE_HOME=\"\$HOME/.heroku/node;" >> $build_dir/.profile.d/nodejs.sh

# Also export PATH and NODE_HOME for subsequent buildpacks
echo "export PATH=\"\$HOME/.heroku/node/bin:\$HOME/bin:\$HOME/node_modules/.bin:\$PATH\";" > $bp_dir/export
echo "export NODE_HOME=\"\$HOME/.heroku/node;" >> $bp_dir/export

####### Clean up

status "Cleaning up build artifacts"

# Clear temporary files
rm -rf $heroku_dir/temp

# Pick up after npm
rm -rf "$build_dir/.node-gyp"
rm -rf "$build_dir/.npm"

# Clear the cache
rm -rf $cache_dir/node

####### Build successful! Store results in cache

# Create the cache
mkdir -p $cache_dir/node

echo $node_version > $cache_dir/node/node-version

if test -d $build_dir/node_modules; then
  status "Caching node_modules for future builds"
  cp -r $build_dir/node_modules $cache_dir/node
fi
