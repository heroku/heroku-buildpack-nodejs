#!/usr/bin/env bash

# testing monitor_memory_usage

# allocate ~14 mb of memory and wait a bit
use_memory() {
  for index in $(seq 10); do
    value=$(seq -w -s '' $index $(($index + 100000)))
    eval array$index=$value
  done
  sleep 0.5
}

# print each argument to a separate line on stdout
print_args() {
  while (( "$#" )); do
    echo $1
    shift
  done
}

print_number_args() {
  echo "$#"
}

testOutput() {
  local stdout

  stdout=$(echo '    Indented line' | output /dev/null)
  assertEquals 'should preserve leading whitespace' '           Indented line' "${stdout}"

  stdout=$(echo 'Foo \ bar' | output /dev/null)
  assertEquals 'should preserve unescaped backslashes' '       Foo \ bar' "${stdout}"
}

testKeyValue() {
  local store=$(mktemp)

  kv_create $store

  kv_set $store key value
  kv_set $store foo bar
  kv_set $store key other_value
  kv_set $store bar baz

  assertEquals "other_value" "$(kv_get $store key)"
  assertEquals "bar" "$(kv_get $store foo)"
  assertEquals "baz" "$(kv_get $store bar)"

  # if the key isn't there it should return an empty string
  assertEquals "" "$(kv_get $store not_there)"

  # kv_keys returns each key on a new line
  assertEquals "$(printf "%s\n" bar foo key)" "$(kv_keys $store)"

  # kv_list returns key=value on individual lines
  assertEquals "$(printf "%s\n" bar=baz foo=bar key=other_value)" "$(kv_list $store)"

  # calling create on an existing store doesn't erase it
  kv_create $store
  assertEquals "$(printf "%s\n" bar=baz foo=bar key=other_value)" "$(kv_list $store)"

  # now clear the store
  kv_clear $store

  assertEquals "" "$(kv_get $store key)"
  assertEquals "" "$(kv_keys $store)"
  assertEquals "" "$(kv_list $store)"
}

testKeyValueNoNewLine() {
  local store

  # use a fixture that does not have an empty line after the final entry
  store="$(pwd)/test/unit-fixtures/kvstore/no-new-line"

  assertEquals "$(printf "%s\n" a=b b=c)" "$(kv_list $store)"
  assertEquals "$(printf "%s\n" a b)" "$(kv_keys $store)"
}

testKeyValueEmptyLine() {
  local store

  # use a fixture that has an extra empty line
  store="$(pwd)/test/unit-fixtures/kvstore/empty-line"

  assertEquals "$(printf "%s\n" a=b b=c)" "$(kv_list $store)"
  assertEquals "$(printf "%s\n" a b)" "$(kv_keys $store)"
}

testKeyValueEscaping() {
  local store=$(mktemp)

  kv_create $store

  kv_set $store "key" "value with a space"
  assertEquals "key=\"value with a space\"" "$(kv_list $store)"
  assertEquals "value with a space" "$(kv_get $store "key")"
}

# if the file doesn't exist, everything should be a no-op
testKeyValueNoFile() {
  # empty file argument
  local empty=""

  kv_set $empty key value

  assertEquals "$(kv_get $empty key)" ""
  assertEquals "$(kv_keys $empty)" ""
  assertEquals "$(kv_list $empty)" ""

  local store="/tmp/does-not-exist"

  kv_set $store key value

  assertEquals "" "$(kv_get $store key)"
  assertEquals "" "$(kv_keys $store)"
  assertEquals "" "$(kv_list $store)"

  # running these commands has not created this file
  assertTrue "[[ ! -e $store ]]"

  local space=" "
  kv_set $space key value

  assertEquals "$(kv_get $space key)" ""
  assertEquals "$(kv_keys $space)" ""
  assertEquals "$(kv_list $space)" ""
}

testWebConcurrencyDoesNotOverrideManualValue() {
  WEB_CONCURRENCY=123

  source "$(pwd)"/profile/WEB_CONCURRENCY.sh

  assertEquals 123 "$WEB_CONCURRENCY"
}

testWebConcurrencySetsAValueWhenUnset() {
  unset WEB_CONCURRENCY

  source "$(pwd)"/profile/WEB_CONCURRENCY.sh

  assertNotNull "WEB_CONCURRENCY is null" "$WEB_CONCURRENCY"
}

testWebConcurrencyProfileScript() {
  # this was set when we sourced the WEB_CONCURRENCY.sh file
  unset WEB_MEMORY
  unset MEMORY_AVAILABLE
  unset WEB_CONCURRENCY

  # memory in MB of a 2X dyno
  assertEquals "512" "$(bound_memory 512)"

  # memory in MB of a 2X dyno
  assertEquals "1024" "$(bound_memory 1024)"

  # memory in MB of a Peformance-M dyno
  assertEquals "2560" "$(bound_memory 2560)"

  # memory in MB of a Peformance-L dyno
  assertEquals "14336" "$(bound_memory 14336)"

  # On non-Heroku systems `detect_memory` can return non-sensically large values
  # so bound to largest known dyno size
  assertEquals "129024" "$(bound_memory 129024)"

  # One larger than largest known
  assertEquals "129024" "$(bound_memory 129025)"

  # test calculate_concurrency

  # 1x
  assertEquals "1" "$(calculate_concurrency 512 512)"
  # 2x
  assertEquals "2" "$(calculate_concurrency 1024 512)"
  # Performance-M
  assertEquals "5" "$(calculate_concurrency 2560 512)"
  # Performance-L
  assertEquals "28" "$(calculate_concurrency 14336 512)"
  # Memory heavy
  assertEquals "31" "$(calculate_concurrency 63488 2048)"

  # In case some very large memory available value gets passed in
  assertEquals "1" "$(validate_concurrency $(calculate_concurrency 103401 512))"
  # of if web memory is set really low
  assertEquals "1" "$(validate_concurrency $(calculate_concurrency 512 1))"
}

isUUID() {
  if [[ ${1//-/} =~ ^[[:xdigit:]]{32}$ ]]; then
    echo true
  else
    echo false
  fi
}

testUUID() {
  local first second
  first=$(uuid)
  second=$(uuid)

  assertNotEquals "$first" "$second"
  assertEquals "true" "$(isUUID "$first")"
  assertEquals "true" "$(isUUID "$second")"
}

testUUIDFallback() {
  local first second
  first=$(uuid_fallback)
  second=$(uuid_fallback)

  assertNotEquals "$first" "$second"
  assertEquals "true" "$(isUUID "$first")"
  assertEquals "true" "$(isUUID "$second")"
}

testHasScript() {
  local file="$(pwd)/test/fixtures/has-script-fixtures/package.json"
  assertEquals "true" "$(has_script "$file" "build")"
  assertEquals "true" "$(has_script "$file" "heroku-postbuild")"
  assertEquals "false" "$(has_script "$file" "postinstall")"
  assertEquals "true" "$(has_script "$file" "random-script-name")"
}

testFeatures() {
  local schema schema2 empty_schema build_dir build_dir_blank build_dir_override cache_dir val val2 val3 val4
  schema="$(pwd)/test/unit-fixtures/features/features"
  schema2="$(pwd)/test/unit-fixtures/features/features-v2"
  empty_schema="$(mktemp)"
  build_dir="$(mktemp -d)"
  build_dir_blank="$(pwd)/test/unit-fixtures/features/build-dir-blank"
  build_dir_override="$(pwd)/test/unit-fixtures/features/build-dir-override"
  cache_dir=$(mktemp -d)

  features_init "nodejs" "$build_dir" "$cache_dir" "$schema"

  # these should always be the same
  assertEquals "true" "$(features_get "all-on")"
  assertEquals "false" "$(features_get "all-off")"
  # these will stay the same between runs
  val="$(features_get "ab-test")"
  val2="$(features_get "ab-test-2")"
  val3="$(features_get "ab-test-3")"
  val4="$(features_get "ab-test-4")"

  # pretend this is the next time this build is run
  features_init "nodejs" "$build_dir" "$cache_dir" "$schema"

  # these should always be the same
  assertEquals "all-on should still be on" "true" "$(features_get "all-on")"
  assertEquals "all-of should still be off" "false" "$(features_get "all-off")"
  # ab-test-x should be the same as it was before
  assertEquals "ab-test should be the same" "$val" "$(features_get "ab-test")"
  assertEquals "ab-test-2 should be the same" "$val2" "$(features_get "ab-test-2")"
  assertEquals "ab-test-3 should be the same" "$val3" "$(features_get "ab-test-3")"
  assertEquals "ab-test-4 should be the same" "$val4" "$(features_get "ab-test-4")"

  # Now we've changed the schema, so the cache should invalidate
  features_init "nodejs" "$build_dir" "$cache_dir" "$schema2"
  # the keys are the same, but the new values should be respected
  assertEquals "invalidate: all-on should be changed" "false" "$(features_get "all-on")"
  assertEquals "invalidate: all-off should be changed" "true" "$(features_get "all-off")"
  assertEquals "invalidate: ab-test should be changed" "false" "$(features_get "ab-test")"

  features_override "ab-test" "true"
  assertEquals "override: ab-test should be true" "true" "$(features_get "ab-test")"
  features_override "ab-test" "false"
  assertEquals "override: ab-test should be false" "false" "$(features_get "ab-test")"

  # now use file-based overrides
  features_init "nodejs" "$build_dir_override" "$cache_dir" "$schema"
  # all of these values should be true now
  assertEquals "override: all-on should be overridden" "true" "$(features_get "all-on")"
  assertEquals "override: all-off should be overridden" "true" "$(features_get "all-off")"
  assertEquals "override: ab-test should be overridden" "true" "$(features_get "ab-test")"

  # file based overrides take precedent over explicit overrides
  features_override "ab-test" "false"
  assertEquals "file based overrides take precedent over explicit overrides" "true" "$(features_get "ab-test")"

  # now use a blank file-based override
  features_init "nodejs" "$build_dir_blank" "$cache_dir" "$schema"
  # all of these values should be false now
  assertEquals "blank: all-on should be off" "false" "$(features_get "all-on")"
  assertEquals "blank: all-off should be off" "false" "$(features_get "all-off")"
  assertEquals "blank: ab-test should be off" "false" "$(features_get "ab-test")"

  #initializing with an empty schema doesn't error
  features_init "nodejs" "$(mktemp -d)" "$(mktemp -d)" "$empty_schema"
}

testFeaturesNoInit() {
  assertEquals "running features_get without init should return false" "false" "$(features_get "test-name")"
  assertEquals "running features_get without init should return false" "false" "$(features_get "test-name-2")"
  assertEquals "running features_get without init should return false" "false" "$(features_get "test-name-3")"
}

testAssertMetricsBasicQueries() {
  local cache_dir=$(mktemp -d)
  local metrics_dir="${cache_dir}/build-data"
  local metrics_file="${metrics_dir}/nodejs.json"
  
  # Create the metrics directory and file
  mkdir -p "$metrics_dir"
  
  # Test basic jq queries
  echo '{"package_manager": "npm", "build_time": 1.234, "cache_status": "not-found"}' > "$metrics_file"
  assertMetrics "$cache_dir" <<-EOF
    select(.package_manager == "npm")
    select(.build_time | type == "number")
    select(.cache_status == "not-found")
EOF
  
  # Cleanup
  rm -rf "$cache_dir"
}

testAssertMetricsMissingArgument() {
  local error_output
  error_output=$(assertMetrics <<-EOF 2>&1 || true
EOF
)
  if ! echo "$error_output" | grep -q "cache_dir argument is required"; then
    fail "assertMetrics should have failed with appropriate error message for missing argument"
  fi
}

testAssertMetricsNonExistentFile() {
  local cache_dir=$(mktemp -d)
  local error_output
  error_output=$(assertMetrics "$cache_dir" <<-EOF 2>&1 || true
    select(.package_manager == "npm")
EOF
)
  if ! echo "$error_output" | grep -q "Metrics file not found"; then
    fail "assertMetrics should have failed with appropriate error message for non-existent file"
  fi
  
  # Cleanup
  rm -rf "$cache_dir"
}

testAssertMetricsInvalidJqQuery() {
  local cache_dir=$(mktemp -d)
  local metrics_dir="${cache_dir}/build-data"
  local metrics_file="${metrics_dir}/nodejs.json"
  
  # Create the metrics directory and file
  mkdir -p "$metrics_dir"
  echo '{"package_manager": "npm"}' > "$metrics_file"
  
  local error_output
  error_output=$(assertMetrics "$cache_dir" <<-EOF 2>&1 || true
    select(.nonexistent == "value")
EOF
)
  if ! echo "$error_output" | grep -q "jq query failed"; then
    fail "assertMetrics should have failed with appropriate error message for invalid jq query"
  fi
  
  # Cleanup
  rm -rf "$cache_dir"
}

testAssertMetricsUncheckedKeys() {
  local cache_dir=$(mktemp -d)
  local metrics_dir="${cache_dir}/build-data"
  local metrics_file="${metrics_dir}/nodejs.json"
  
  # Create the metrics directory and file
  mkdir -p "$metrics_dir"
  echo '{"package_manager": "npm", "build_time": 1.234, "cache_status": "not-found"}' > "$metrics_file"
  
  local error_output
  error_output=$(assertMetrics "$cache_dir" <<-EOF 2>&1 || true
    select(.package_manager == "npm")
EOF
)
  if ! echo "$error_output" | grep -q "keys in the metrics file were not checked: \[build_time,cache_status\]"; then
    fail "assertMetrics should have failed with appropriate error message for unchecked keys"
  fi
  
  # Cleanup
  rm -rf "$cache_dir"
}

testAssertMetricsAllKeysChecked() {
  local cache_dir=$(mktemp -d)
  local metrics_dir="${cache_dir}/build-data"
  local metrics_file="${metrics_dir}/nodejs.json"
  
  # Create the metrics directory and file
  mkdir -p "$metrics_dir"
  echo '{"package_manager": "npm", "build_time": 1.234, "cache_status": "not-found"}' > "$metrics_file"
  
  # Should pass when all keys are checked
  assertMetrics "$cache_dir" <<-EOF
    select(.package_manager == "npm")
    select(.build_time | type == "number")
    select(.cache_status == "not-found")
EOF
  
  # Cleanup
  rm -rf "$cache_dir"
}

BP_DIR="$(pwd)"

# the modules to be tested

source "$(pwd)"/lib/vendor/stdlib_v7.sh
source "$(pwd)"/lib/uuid.sh
source "$(pwd)"/lib/environment.sh
source "$(pwd)"/lib/json.sh
source "$(pwd)"/lib/json.sh
source "$(pwd)"/lib/monitor.sh
source "$(pwd)"/lib/output.sh
source "$(pwd)"/lib/kvstore.sh
source "$(pwd)"/lib/features.sh
source "$(pwd)"/profile/WEB_CONCURRENCY.sh

# testing utils
source "$(pwd)"/test/utils

# import the testing framework
source "$(pwd)"/test/shunit2
