#!/usr/bin/env bash
# Shared helper functions for split test runners.
# Source this file from each test runner; it does NOT source shunit2.

pushd "$(dirname 0)" >/dev/null
popd >/dev/null

source "$(pwd)"/test/utils
source "$(pwd)"/lib/environment.sh

mktmpdir() {
  dir=$(mktemp -t testXXXXX)
  rm -rf $dir
  mkdir $dir
  echo $dir
}

compile_dir=""

default_process_types_cleanup() {
  file="/tmp/default_process_types"
  if [ -f "$file" ]; then
    rm "$file"
  fi
}

detect() {
  default_process_types_cleanup
  bp_dir=$(mktmpdir)
  compile_dir=$(mktmpdir)
  cp -a "$(pwd)"/* ${bp_dir}
  cp -a ${bp_dir}/test/fixtures/$1/. ${compile_dir}
  capture ${bp_dir}/bin/detect ${compile_dir}
}

# $1 - The fixture to compile
# $2 - The cache directory (defaults to a new temp directory)
# $3 - The env directory (defaults to a new temp directory)
# $4 - the compile directory (defaults to a new temp directory)
#
# Note - It would be nice if the compile directory wasn't the 4th arg to this function so that
#        the expected arguments would line up with the buildpack's compile invocation of
#        `compile "$BUILD_DIR" "$CACHE_DIR" "$ENV_DIR"` but this would require all existing tests
#        to reorder their arguments as allowing a configurable compile directory was added last.
compile() {
  default_process_types_cleanup

  bp_dir=$(mktmpdir)
  compile_dir=${4:-$(mktmpdir)}

  cp -a "$(pwd)"/* ${bp_dir}
  cp -a ${bp_dir}/test/fixtures/$1/. ${compile_dir}

  # if there isn't a features override, add an empty one to ensure
  # that any features will not influence tests unless they are
  # explicitly defined
  if [[ ! -f "${compile_dir}/heroku-buildpack-features" ]]; then
    touch "${compile_dir}/heroku-buildpack-features"
  fi

  capture ${bp_dir}/bin/compile ${compile_dir} ${2:-$(mktmpdir)} $3
}

# run compile on a fixture and then capture the output of bin/report
# ran after bin/compile completes, reusing the cache and env dirs. Note
# that the output of bin/compile will not be captured
compile_and_report() {
  default_process_types_cleanup
  cache_dir=${2:-$(mktmpdir)}
  env_dir=${3:-$(mktmpdir)}

  bp_dir=$(mktmpdir)
  cp -a "$(pwd)"/* ${bp_dir}

  compile_dir=$(mktmpdir)
  cp -a ${bp_dir}/test/fixtures/$1/. ${compile_dir}

  # if there isn't a features override, add an empty one to ensure
  # that any features will not influence tests unless they are
  # explicitly defined
  if [[ ! -f "${compile_dir}/heroku-buildpack-features" ]]; then
    touch "${compile_dir}/heroku-buildpack-features"
  fi

  ${bp_dir}/bin/compile ${compile_dir} $cache_dir $env_dir > /dev/null 2>/dev/null
  capture ${bp_dir}/bin/report ${compile_dir} $cache_dir $env_dir
}

# Run bin/report on a set of given directories without first invoking bin/compile
# This is useful because in the case of a buildpack bug, you cannot trust that
# any binaries will be installed or any part of the cache available, and bin/report
# should be resilient in that case.
report() {
  default_process_types_cleanup

  compile_dir=${1:-$(mktmpdir)}
  cache_dir=${2:-$(mktmpdir)}
  env_dir=${3:-$(mktmpdir)}

  bp_dir=$(mktmpdir)
  cp -a "$(pwd)"/* ${bp_dir}

  capture ${bp_dir}/bin/report ${compile_dir} ${cache_dir} ${env_dir}
}

testCompile() {
  default_process_types_cleanup
  bp_dir=$(mktmpdir)
  compile_dir=$(mktmpdir)
  cp -a "$(pwd)"/* ${bp_dir}
  cp -a ${bp_dir}/test/fixtures/$1/. ${compile_dir}
  capture ${bp_dir}/bin/test-compile ${compile_dir} ${2:-$(mktmpdir)} $3
}

# This is meant to be run after `compile`. `cleanupStartup` must be run
# after this function is called before other tests are executed
executeStartup() {
  local env_dir=$1

  # On Heroku, $HOME is the /app dir, so we need to set it to
  # the compile_dir here
  export HOME=${compile_dir}

  # we need to set any environment variables set via the env_dir and run
  # all of the .profile.d scripts
  export_env_dir $env_dir

  for f in ${compile_dir}/.profile.d/*; do source $f > /dev/null 2> /dev/null ; done
}

cleanupStartup() {
  unset HOME
  unset NODE_ENV
  unset NODE_HOME
  unset NODE_OPTIONS
  unset DYNO
  unset HEROKU_METRICS_URL
  unset HEROKU_SKIP_NODE_PLUGIN
}

compileTest() {
  default_process_types_cleanup

  local bp_dir=$(mktmpdir)
  local compile_dir=$(mktmpdir)
  local cache_dir=${2:-$(mktmpdir)}
  local env_dir=$3

  cp -a "$(pwd)"/* ${bp_dir}
  cp -a ${bp_dir}/test/fixtures/$1/. ${compile_dir}
  capture ${bp_dir}/bin/test-compile ${compile_dir} ${2:-$(mktmpdir)} $3

  # On Heroku, $HOME is the /app dir, so we need to set it to
  # the compile_dir here
  export HOME=${compile_dir}

  # bin/test is not ran during build, rather during runtime, which means
  # we need to set any environment variables set via the env_dir and run
  # all of the .profile.d scripts
  export_env_dir $env_dir
  for f in ${compile_dir}/.profile.d/*; do source $f > /dev/null 2> /dev/null ; done

  capture ${bp_dir}/bin/test ${compile_dir}

  unset HOME
  unset NODE_ENV
  unset NODE_HOME
}

compileDir() {
  default_process_types_cleanup

  local bp_dir=$(mktmpdir)
  local compile_dir=${1:-$(mktmpdir)}
  local cache_dir=${2:-$(mktmpdir)}
  local env_dir=$3

  cp -a "$(pwd)"/* ${bp_dir}
  capture ${bp_dir}/bin/compile ${compile_dir} ${cache_dir} ${env_dir}
}

release() {
  bp_dir=$(mktmpdir)
  cp -a "$(pwd)"/* ${bp_dir}
  capture ${bp_dir}/bin/release ${bp_dir}/test/fixtures/$1
}

assertFile() {
  assertEquals "$1" "$(cat ${compile_dir}/$2)"
}

tearDown() {
  # Remove any testing temporary directories created during tests to prevent
  # CI from running out of disk space.
  for dir in $bp_dir $compile_dir $cache_dir $env_dir;
  do
    if [[ -d $dir ]] && [[ "$dir" =~ test[[:alnum:]]{5}$ ]]; then
      rm -rf $dir
    fi
  done
}
